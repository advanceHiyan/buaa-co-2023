#CPU设计文档Verilog

##思考题
1，MIPS中以字节为单位，而在我们设计的DM中，每一个32位reg变量为一个单位。32位等于4字节，因此多了两位，又因为按字节寻址，因此取[11:2]（本次设计IM是4096字，DM是3072字所以应该是[13:2]）。

2什么叫“上述两种”，上面哪里述了？
不过控制器可能有assign配合三目运算符模块和always@（*）配合if或者case两种方式。
我用的是后者
```
always @(*)begin
		if(add | sub | beq )begin
			 ABsel = 3'b000;//rd2
		end
		else if(sw | lw | lui | ori)begin
			 ABsel = 3'b001;//ext
		end
		else  ABsel = 3'b000;
		
		if((add | lw | sw))begin
			 ALUop = 3'b000;//+
		end
		else if(sub | beq)begin
			 ALUop = 3'b001;//-
		end
		else if(ori)begin
			 ALUop = 3'b011;// |
		end
		else  ALUop = 3'b000;
```
这是示例代码，我写的代码是真的漂亮。
一般来讲，assign配合三目运算符简单而直观，并且很难有难以发现的bug。但是用always写组合逻辑就可能会出现难以预料的bug。

3，异步复位，二者优先级相同，同步复位clk优先级更高

4，根据英文指令集，addi和add指令具体执行的时候有一个判断溢出的if（）语句，假如不考虑溢出的话可以优化if语句，优化以后，add和addu的英文操作过程完全相同，addi与addiu亦然。

##设计思路

本人此次设计几乎完全照搬了p3的logisim设计，只是把各种电路翻译成了verilog语言而已。但是即使是翻译，在搭建过程中依旧遇到了许多困难。尤其是verilog很难debug，有时候一个电路名称写错了，或者一条线忘记连了就得找好久，因为verilog实在是太不直观了。即使写了_tb文件进行仿真，有些bug也很难调试出来。

值得注意的是，im的初始地址32'h0000_3000真的很难搞，于是我就初始化地址是0，然后输出PC的时候和执行jal朝31号寄存器写入的时候加上了32'h0000_3000，并在执行jal和jr的跳转时，减去了32'h0000_3000，勉强最后跳转正确，没有运行错误。

##测试方案

首先比较粗暴地测试方式就是用lSim仿真，确实是好用功能非常强大，就是界面不好看，所以还不是很会用。

其次，是请教了学长，然后试着写了comp测试文件，把所有.v文件和相关测试文件放进src文件夹然后用c语言或者Java生成一些随机测试点进行测试并使用assert断言进行检测……

 
 但是不太成功……